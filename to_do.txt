To Do:
------
1. Upgrade to Godot 4.0 (whenever that happens): GDScript

    There's a lot of features in Godot 4.0, including several updates to
    GDScript. I don't think I need any of those particular new GDScript
    features, but it introduces several drastic incompatabilities with our
    existing code - especially around setters and getters. We need several of
    Godot 4.0's other features; but before we get to those, we'll have to solve
    any outstanding GDScript issues.
    
2. Upgrade to Godot 4.0 (whenever that happens): Navigation

    We're currently using some features supplied via addon (i.e. Miloš Lukić's 
    Godot Navigation Lite) that are supported in the base version of Godot 4.0.
    We should upgrade to 4.0 as soon as possible. It's just a question of
    whenever that comes out...

3. Design a KinematicDriver-esque node using State Machines

    We need to come up with a way to integrate attacks into some sort of
    coherent AI. To be frank, I don't really think there's a good way to do that
    with how we have stuff set up right now. I like the concept of the
    KinematicDriver, but we need to rethink how we do AI.
    
    We should really use a state-machine like approach. I just don't think
    there's a better way to do it - the segmenting of different functions into
    small scripts really is the best way to do it.
    
    Godot provides a sample demonstration on how a state-machine can be
    implemented. The Asset Lib also has several assets that can help us
    implement a proper state-machine.
    
    To start, we should see if we can design something akin to the
    KinematicDriver that acts using a state machine.

4. Update the TestShell and SlopeStepTest to use XSM

    I'm not done implementing the KinematicDriver with XSM yet, but I'm very
    happy with it so far. There's actually been several instances where I tried
    to implement something revolving around states and transitioning between
    states and... the whole affair was pretty painful.
    
    XSM will allow us to smooth over that bumpy code with only a bit of code and
    some new nodes. We should update two particularly painful items that were a
    bit more painful than they should've been: the TestShell and the
    SlopeStepTest.

5. Develop sword attacks

    Using knowledge gained from creating a KinematicDriver parallel, we need to
    develop a model for attacking stuff. That includes acquiring targets, moving
    to attacking stuff, and actually inflicting damage (including attack
    selection) and possible cool downs.
    
    This AI will need to be integrated with the KinematicDriver... thing that we
    outlined above. So, the Pawn will fall mid-attack, can be interrupted, etc.
    
    This doesn't need to a complete, all-consuming build of the attacks system,
    just enough for the sword to work and for us to have an idea of what's
    happening. What is possible, and what isn't.
    
6. Create weapon models

    We need to create weapons for our pawns to equip! We'll use OpenSCAD to
    design the models. Technically, since we use sprites in-game, we could just
    use models off the internet. However, I want the weapons designed to fit the
    Pawn models - and to be open source.
    
    We'll need:
    - A crossbow
    - A bow
    - A gun (musket-eque)
    - A halberd/pike
    - A shield
    - A torch
    - A knife
    
    And maybe a jezzail - a long rifle of some sort?

7. ATTACKS!
    
    Develop attacks for the weapons outlined above, including ranged attacks.
    That means developing the AI to go with these attacks - positioning and
    attacking at the correct interval. It'll be difficult, but we'll have
    something akin to a prototype when we're done.

8. Improve the Slope-Step Test

    The Slope-Step Test needs some improvement. Right now, we need to wait for
    every single test to fire. Like, we just wait. We've already done something
    better with the Viewport Shader Test - we should migrate the test structure
    (especially the skip test button) from that scene.
    
9. Come up with a way to bake the procedural building components (?)

    I'm worried about the impact of the procedural building components on the
    game's performance. Once they're generated there's no issue but it's the
    start-up and load time that I'm worried about.

    It's possible for us to save the array meshes once they've been generated.
    I think we can create a plugin that will allow us to bake the components
    on-demand. We'll probably need to create a separate set of "baked" scenes.

    I'm still unsure about whether this is something even worth doing or not.
    I'll mull it over...

