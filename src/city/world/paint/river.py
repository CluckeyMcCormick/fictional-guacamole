
import enum
import math

import noise

from ..assets.terrain_primary import PrimaryKey
import game_util

class RiverFlow(enum.IntEnum):
    """
    Describes the flow direction of a particular river segment; used for the
    semantics of river flow.
    """
    EAST = 0
    NORTH_EAST = 1
    NORTH = 2
    NORTH_WEST = 3
    WEST = 4
    SOUTH_WEST = 5
    SOUTH = 6
    SOUTH_EAST = 7

"""
The flow_shifts dict contains flow_shifts tuples, which describe the
flow_shifts on x and y that match a particular flow. For example, if we have a
river flowing east, we want to move in an easterly direction. We would index
this dictionary with RiverFlow.EAST and get (1, 0). Thus, we can calculate due
east with x + 1, y + 0.

Also, this had to be defined outside of it's class because OTHERWISE it would
become an enum itself and be useless.
"""
flow_shifts = {
    RiverFlow.EAST: (1, 0),
    RiverFlow.NORTH: (0, 1),
    RiverFlow.WEST: (-1, 0),
    RiverFlow.SOUTH: (0, -1),
    RiverFlow.NORTH_EAST: ( 1, 1),
    RiverFlow.NORTH_WEST: (-1, 1),   
    RiverFlow.SOUTH_WEST: (-1,-1),
    RiverFlow.SOUTH_EAST: ( 1,-1)
}

class RiverOrient(enum.Enum):
    """
    Describes the overall orientation of the river; independent from the
    direction of the water's flow.
    """
    # A Left<->Right (West<->East) configuration
    HORIZONTAL = 0

    # A Positive Slope, Lower Left<->Upper Right (South West<->North East)
    POS_SLOPE = 1
    
    # A Up<->Down (North<->South) configuration
    VERTICAL = 2
    
    # A Negative Slope, Upper Left<->Lower Right (North West<->South East)
    NEG_SLOPE = 3

class RiverSegment(object):
    """
    Describes a segment of a river, where each segment is a 1-thick slice of a
    river along it's width.
    """
    def __init__(self, pos, orient, flow, size):
        """
        Creates a segment of a river.

        Inputs:

        pos: a (x, y) tuple that specifies the semantic center of the river

        orient: a RiverOrient enum that specfies how the river is oriented

        flow: a RiverFlow enum that describes the flow of the water in this
        segment

        size: the size/width of the river
        """
        super(RiverSegment, self).__init__()
        self.pos = pos
        self.orient = orient
        self.flow = flow
        self.size = size
        
def make_river(world_data, start, generators):
    """
    Generates a river object. 

    For generating a river, we add together the values produced by the provided
    generators. This is interpreted as a heightmap; the river is generated by
    using this heightmap as a watershed. That means that the provided
    generators need to provide some form of direction to the river or things
    could go badly - infinite loop badly.

    Inputs:

    world_data: The WorldData object we will be working on

    start: a (x, y) tuple that specifies the start/source/headwaters of the
    river

    generators: a List of Generator objects

    """
    X_SIZE, Y_SIZE = world_data.sizes

    # Initialize our values: we are at the start, in the map, with no flow
    cur_x, cur_y = start
    in_map = True
    old_flow = None

    river = []

    # While we haven't gone off the map...
    while in_map:

        flow = None
        low_val = math.inf

        # If we don't have a flow...
        if old_flow is None:
            # Then check every direction!
            flow_range = range(0, len(RiverFlow))
            old_flow = 0
        # Otherwise...
        else:
            # Just check the left, forward, and right
            flow_range = range(-1, 2)

        """
        Step 1: Determine which tile to flow into.
        """
        for turn in flow_range:
            # Calculate our new flow value
            adj_flow = (old_flow + turn) % len(RiverFlow)

            # unpack our adjustments for our current flow direction
            adj_x, adj_y = flow_shifts[ adj_flow ]

            # calculate the new X and Y
            new_x = cur_x + adj_x
            new_y = cur_y + adj_y

            # Sum up this value across all the provided generators
            value = 0
            for gen in generators:
                value += gen.get_value(new_x, new_y)

            # If this is currently the lowest value, then update our tracking
            if value < low_val:
                low_val = value
                flow = adj_flow

        """
        Step 2: Create a segment, place it on the stack.
        """
        segment = RiverSegment( 
            (cur_x, cur_y), RiverOrient.HORIZONTAL, RiverFlow(flow), 3
        )
        river.append(segment)

        """
        Step 3: Move to the new tile.
        """ 
        # unpack our adjustments for our new flow direction
        adj_x, adj_y = flow_shifts[ flow ]

        # Adjust the X and Y
        cur_x += adj_x
        cur_y += adj_y

        # Update the old flow
        old_flow = flow

        """
        Step 4: Check if you're still in bounds.
        """
        in_map = (0 <= cur_x < X_SIZE) and (0 <= cur_y < Y_SIZE)

    return river

def paint_river(world_data, tile_set, river):
    """
    Paints the provided river, end to end.
    """
    for segment in river:
        if segment.orient == RiverOrient.HORIZONTAL:
            paint_river_horizontal(world_data, tile_set, segment)

        if segment.orient == RiverOrient.VERTICAL:
            paint_river_vertical(world_data, tile_set, segment)


def paint_river_horizontal(world_data, tile_set, segment):
    pos_x, pos_y = segment.pos
    x_size, _ = world_data.base.sizes

    water_designate = tile_set.get_designate(PrimaryKey.WATER)

    # For every tile...
    for i in range(segment.size):
        # Calculate the disposition - are we adding this on the left or right?
        # We alternate between painting on either side depending on whether
        # we're odd or even - and (conveniently), so does cosine!
        disposition =  math.cos( i * math.pi )

        # Calculate our distance from the "original" point
        new_x = pos_x + ((i + 1) // 2) * int(disposition)

        # If we're not in the limit, skip this tile
        if not (0 <= new_x < x_size):
            continue

        # Paint the tile
        world_data.base[new_x, pos_y] = water_designate

def paint_river_vertical(world_data, tile_set, segment):
    pos_x, pos_y = segment.pos
    _, y_size = world_data.base.sizes

    water_designate = tile_set.get_designate(PrimaryKey.WATER)

    # For every tile...
    for i in range(segment.size):
        # Calculate the disposition - are we adding this on the left or right?
        # We alternate between painting on either side depending on whether
        # we're odd or even - and (conveniently), so does cosine!
        disposition =  math.cos( i * math.pi )

        # Calculate our distance from the "original" point
        new_x = pos_x + ((i + 1) // 2) * int(disposition)

        # If we're not in the limit, skip this tile
        if not (0 <= new_y < y_size):
            continue

        # Paint the tile
        world_data.base[pos_x, new_y] = water_designate
