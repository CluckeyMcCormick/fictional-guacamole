// TCM - the Tasking Coward Machine
// Data Flow - Graphviz Dot
// Directed Graph
digraph G {
    rankdir=LR; // Left to Right, instead of Top to Bottom
    nodesep=.55; // Ensure nodes are separated by at least .55... units?
    overlap=false; // Nodes are not allowed to overlap.
    compound=true; // Allow edges between clusters
    
    // All the nodes are records
    node [shape=record];
    
    ROOT [label="
        <name> Tasking Coward Machine Root |
        <idle_wait> Variable\n\nidle_wait_time |
        <move_dist> Variable\n\nmove_distance | 
        <gr_key> Variable\n\ngoal_key |
        <ptr_key> Variable\n\nphysics_travel_key |
        <curr_orient> Variable\n\n_curr_orient
    "];
    
    PTR [label="
        <name> Physics Travel Region |
        <sgnl_complete> Signal\n\npath_complete |
        <sgnl_stuck> Signal\n\nerror_goal_stuck |
        <targ_pos> Variable\n\n_target_position |
        <targ_path> Variable\n\n_target_path |
        <states> \nSub-States
    "];

    TMR [label="
        <name> Task Manager Region |
        <sgnl_complete> Signal\n\ncurrent_task_succeeded |
        <sgnl_stuck> Signal\n\ncurrent_task_failed |
        <task> Current Task |
        <actions> \nActions (Sub-States)
    "];
    
    GR [label="
        <name> Goal Region |
        <states> \nSub-States
    "];

    SSC [label="
        <name> Sensory Sort Core|
        <body_entered> Signal\n\nbody_entered |
        <body_exited> Signal\n\nbody_exited
    "];
    
    // Sensory Sort Core Signal Edges
    edge [color="crimson", style="dashed"];
    SSC:body_entered:e -> GR:states:w;
    SSC:body_exited:e -> GR:states:w;
    SSC:body_entered:e -> TMR:actions:w;
    SSC:body_exited:e -> TMR:actions:w;
    
    // Signal Edges
    edge [style="solid"];
    PTR:sgnl_complete -> TMR:actions;
    PTR:sgnl_stuck -> TMR:actions;
    TMR:sgnl_complete -> GR:states;
    TMR:sgnl_stuck -> GR:states;
    
    // Data Manipulation Edges
    edge [color="dodgerblue"];
    TMR:actions:s -> PTR:targ_pos;
    TMR:actions:s -> PTR:targ_path;
    GR:states:s -> TMR:task:e;
    GR:states:s -> ROOT:gr_key;
    PTR:states -> ROOT:ptr_key;
    PTR:states -> ROOT:curr_orient;
}
